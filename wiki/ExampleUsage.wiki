Example usage for the included trees.

<wiki:toc max_depth="2" />

== Concurrent Radix Tree ==
=== Objective ===
  * Create a concurrent radix tree
  * Insert keys "TEST", "TOAST", "TEAM", associate with integer values 1, 2, 3
  * Graphically print the structure of the tree
  * Find keys starting with "T", "TE"
  * Find values for keys starting with "T", "TE"
  * Find key-value pairs for keys starting with "T", "TE"

=== Code ===
{{{
public static void main(String[] args) {
    RadixTree<Integer> tree = new ConcurrentRadixTree<Integer>(new NaiveCharArrayNodeFactory());

    tree.put("TEST", 1);
    tree.put("TOAST", 2);
    tree.put("TEAM", 3);

    System.out.println("Tree structure:");
    // PrettyPrintable is a non-public API for testing, prints semi-graphical representations of trees...
    PrettyPrintUtil.prettyPrint((PrettyPrintable)tree, System.out);

    System.out.println();
    System.out.println("Value for 'TEST' (exact match): " + tree.getValueForExactKey("TEST"));
    System.out.println("Value for 'TOAST' (exact match): " + tree.getValueForExactKey("TOAST"));
    System.out.println();
    System.out.println("Keys starting with 'T': " + tree.getKeysStartingWith("T"));
    System.out.println("Keys starting with 'TE': " + tree.getKeysStartingWith("TE"));
    System.out.println();
    System.out.println("Values for keys starting with 'TE': " + tree.getValuesForKeysStartingWith("TE"));
    System.out.println("Key-Value pairs for keys starting with 'TE': " + tree.getKeyValuePairsForKeysStartingWith("TE"));
}
}}}

=== Output ===
{{{
Tree structure:
○
└── ○ T
    ├── ○ E
    │   ├── ○ AM (3)
    │   └── ○ ST (1)
    └── ○ OAST (2)

Value for 'TEST' (exact match): 1
Value for 'TOAST' (exact match): 2

Keys starting with 'T': [TEAM, TEST, TOAST]
Keys starting with 'TE': [TEAM, TEST]

Values for keys starting with 'TE': [3, 1]
Key-Value pairs for keys starting with 'TE': [(TEAM, 3), (TEST, 1)]
}}}

----
== Concurrent Reversed Radix Tree ==
=== Objective ===
  * Create a concurrent reversed radix tree
  * Insert keys "TEST", "TOAST", "TEAM", associate with integer values 1, 2, 3
  * Graphically print the structure of the tree
  * Find keys ending with "ST", "M"
  * Find values for keys ending with "ST"
  * Find key-value pairs for keys ending with "ST"

=== Code ===
{{{
public static void main(String[] args) {
    ReversedRadixTree<Integer> tree = new ConcurrentReversedRadixTree<Integer>(new NaiveCharArrayNodeFactory());

    tree.put("TEST", 1);
    tree.put("TOAST", 2);
    tree.put("TEAM", 3);

    System.out.println("Tree structure:");
    // PrettyPrintable is a non-public API for testing, prints semi-graphical representations of trees...
    PrettyPrintUtil.prettyPrint((PrettyPrintable)tree, System.out);

    System.out.println();
    System.out.println("Value for 'TEST' (exact match): " + tree.getValueForExactKey("TEST"));
    System.out.println("Value for 'TOAST' (exact match): " + tree.getValueForExactKey("TOAST"));
    System.out.println();
    System.out.println("Keys ending with 'ST': " + tree.getKeysEndingWith("ST"));
    System.out.println("Keys ending with 'M': " + tree.getKeysEndingWith("M"));
    System.out.println();
    System.out.println("Values for keys ending with 'ST': " + tree.getValuesForKeysEndingWith("ST"));
    System.out.println("Key-Value pairs for keys ending with 'ST': " + tree.getKeyValuePairsForKeysEndingWith("ST"));
}
}}}

=== Output ===
{{{
Tree structure:
○
├── ○ MAET (3)
└── ○ TS
    ├── ○ AOT (2)
    └── ○ ET (1)

Value for 'TEST' (exact match): 1
Value for 'TOAST' (exact match): 2

Keys ending with 'ST': [TOAST, TEST]
Keys ending with 'M': [TEAM]

Values for keys ending with 'ST': [2, 1]
Key-Value pairs for keys ending with 'ST': [(TOAST, 2), (TEST, 1)]
}}}

----
== Concurrent Inverted Radix Tree ==
=== Objective ===
  * Create a concurrent inverted radix tree
  * Insert *_keywords_* "TEST", "TOAST", "TEAM", associate with integer values 1, 2, 3
  * Graphically print the structure of the tree
  * Find keywords *_contained in example document_* "MY TEAM LIKES TOAST"
  * Find keywords contained in example document "MY TEAM LIKES TOASTERS"
  * Find values for keywords contained in example document "MY TEAM LIKES TOAST"
  * Find keyword-value pairs for keywords contained in example document "MY TEAM LIKES TOAST"

=== Code ===
{{{
public static void main(String[] args) {
    InvertedRadixTree<Integer> tree = new ConcurrentInvertedRadixTree<Integer>(new NaiveCharArrayNodeFactory());

    tree.put("TEST", 1);
    tree.put("TOAST", 2);
    tree.put("TEAM", 3);

    System.out.println("Tree structure:");
    // PrettyPrintable is a non-public API for testing, prints semi-graphical representations of trees...
    PrettyPrintUtil.prettyPrint((PrettyPrintable)tree, System.out);

    System.out.println();
    System.out.println("Value for 'TEST' (exact match): " + tree.getValueForExactKey("TEST"));
    System.out.println("Value for 'TOAST' (exact match): " + tree.getValueForExactKey("TOAST"));
    System.out.println();
    System.out.println("Keys contained in 'MY TEAM LIKES TOAST': " + tree.getKeysContainedIn("MY TEAM LIKES TOAST"));
    System.out.println("Keys contained in 'MY TEAM LIKES TOASTERS': " + tree.getKeysContainedIn("MY TEAM LIKES TOASTERS"));
    System.out.println("Values for keys contained in 'MY TEAM LIKES TOAST': " + tree.getValuesForKeysContainedIn("MY TEAM LIKES TOAST"));
    System.out.println("Key-value pairs for keys contained in 'MY TEAM LIKES TOAST': " + tree.getKeyValuePairsForKeysContainedIn("MY TEAM LIKES TOAST"));
}
}}}

=== Output ===
{{{
Tree structure:
○
└── ○ T
    ├── ○ E
    │   ├── ○ AM (3)
    │   └── ○ ST (1)
    └── ○ OAST (2)

Value for 'TEST' (exact match): 1
Value for 'TOAST' (exact match): 2

Keys contained in 'MY TEAM LIKES TOAST': [TEAM, TOAST]
Keys contained in 'MY TEAM LIKES TOASTERS': [TEAM, TOAST]
Values for keys contained in 'MY TEAM LIKES TOAST': [3, 2]
Key-value pairs for keys contained in 'MY TEAM LIKES TOAST': [(TEAM, 3), (TOAST, 2)]
}}}

----
== Concurrent Suffix Tree ==
=== Objective ===
  * Create a concurrent suffix tree
  * Insert keys "TEST", "TOAST", "TEAM", associate with integer values 1, 2, 3
  * Graphically print the structure of the tree
  * Find keys ending with "ST", "M"
  * Find values for keys ending with "ST"
  * Find key-value pairs for keys ending with "ST"
  * Find keys containing "TE", "A"
  * Find values for keys containing "A"
  * Find key-value pairs for keys containing "A"

=== Code ===
{{{
public static void main(String[] args) {
    System.out.println("Suffixes for 'TEST': " + TestUtils.iterableToString(CharSequenceUtil.generateSuffixes("TEST")));
    System.out.println("Suffixes for 'TOAST': " + TestUtils.iterableToString(CharSequenceUtil.generateSuffixes("TOAST")));
    System.out.println("Suffixes for 'TEAM': " + TestUtils.iterableToString(CharSequenceUtil.generateSuffixes("TEAM")));

    SuffixTree<Integer> tree = new ConcurrentSuffixTree<Integer>(new NaiveCharArrayNodeFactory());

    tree.put("TEST", 1);
    tree.put("TOAST", 2);
    tree.put("TEAM", 3);

    System.out.println();
    System.out.println("Tree structure:");
    // PrettyPrintable is a non-public API for testing, prints semi-graphical representations of trees...
    PrettyPrintUtil.prettyPrint((PrettyPrintable)tree, System.out);

    System.out.println();
    System.out.println("Value for 'TEST' (exact match): " + tree.getValueForExactKey("TEST"));
    System.out.println("Value for 'TOAST' (exact match): " + tree.getValueForExactKey("TOAST"));
    System.out.println();
    System.out.println("Keys ending with 'ST': " + tree.getKeysEndingWith("ST"));
    System.out.println("Keys ending with 'M': " + tree.getKeysEndingWith("M"));
    System.out.println("Values for keys ending with 'ST': " + tree.getValuesForKeysEndingWith("ST"));
    System.out.println("Key-Value pairs for keys ending with 'ST': " + tree.getKeyValuePairsForKeysEndingWith("ST"));
    System.out.println();
    System.out.println("Keys containing 'TE': " + tree.getKeysContaining("TE"));
    System.out.println("Keys containing 'A': " + tree.getKeysContaining("A"));
    System.out.println("Values for keys containing 'A': " + tree.getValuesForKeysContaining("A"));
    System.out.println("Key-Value pairs for keys containing 'A': " + tree.getKeyValuePairsForKeysContaining("A"));
}
}}}

=== Output ===
{{{
Suffixes for 'TEST': [TEST, EST, ST, T]
Suffixes for 'TOAST': [TOAST, OAST, AST, ST, T]
Suffixes for 'TEAM': [TEAM, EAM, AM, M]

Tree structure:
○
├── ○ A
│   ├── ○ M ([TEAM])
│   └── ○ ST ([TOAST])
├── ○ E
│   ├── ○ AM ([TEAM])
│   └── ○ ST ([TEST])
├── ○ M ([TEAM])
├── ○ OAST ([TOAST])
├── ○ ST ([TOAST, TEST])
└── ○ T ([TOAST, TEST])
    ├── ○ E
    │   ├── ○ AM ([TEAM])
    │   └── ○ ST ([TEST])
    └── ○ OAST ([TOAST])

Value for 'TEST' (exact match): 1
Value for 'TOAST' (exact match): 2

Keys ending with 'ST': [TOAST, TEST]
Keys ending with 'M': [TEAM]
Values for keys ending with 'ST': [2, 1]
Key-Value pairs for keys ending with 'ST': [(TEST, 1), (TOAST, 2)]

Keys containing 'TE': [TEAM, TEST]
Keys containing 'A': [TEAM, TOAST]
Values for keys containing 'A': [3, 2]
Key-Value pairs for keys containing 'A': [(TEAM, 3), (TOAST, 2)]
}}}

----
== Find Longest Common Substring in a Collection of Documents ==
=== Objective ===
  * Solve the [http://en.wikipedia.org/wiki/Longest_common_substring_problem longest common substring problem] using the included `LCSubstringSolver`

=== Code ===
{{{
static final String document1 =
        "albert einstein, was a german theoretical physicist who developed the theory of general relativity";

static final String document2 =
        "near the beginning of his career, albert einstein thought that newtonian mechanics was no longer " +
        "enough to reconcile the laws of classical mechanics with the laws of the electromagnetic field";

static final String document3 =
        "in late summer 1895, at the age of sixteen, albert einstein sat the entrance examinations for " +
        "the swiss federal polytechnic in zurich";

public static void main(String[] args) {
    LCSubstringSolver solver = new LCSubstringSolver(new NaiveCharSequenceNodeFactory());

    solver.add(document1);
    solver.add(document2);
    solver.add(document3);

    String longestCommonSubstring = CharSequenceUtil.toString(solver.getLongestCommonSubstring());
    System.out.println(longestCommonSubstring);
}
}}}

=== Output ===
{{{
albert einstein
}}}

----