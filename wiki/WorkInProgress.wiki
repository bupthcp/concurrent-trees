#labels Deprecated
== Example Usage ==

=== Concurrent Radix Tree ===
==== Objective ====
  * Create a concurrent radix tree
  * Insert keys "TEST", "TOAST", "TEAM", associate with integer values 1, 2, 3
  * Graphically print the structure of the tree
  * Find keys starting with "T", "TE"
  * Find values for keys starting with "T", "TE"
  * Find key-value pairs for keys starting with "T", "TE"

==== Code ====
{{{
public static void main(String[] args) {
    RadixTree<Integer> tree = new ConcurrentRadixTree<Integer>(new NaiveCharArrayNodeFactory());

    tree.put("TEST", 1);
    tree.put("TOAST", 2);
    tree.put("TEAM", 3);

    System.out.println("Tree structure:");
    // PrettyPrintable is a non-public API for testing, prints semi-graphical representations of trees...
    PrettyPrintUtil.prettyPrint((PrettyPrintable)tree, System.out);

    System.out.println();
    System.out.println("Value for 'TEST' (exact match): " + tree.getValueForExactKey("TEST"));
    System.out.println("Value for 'TOAST' (exact match): " + tree.getValueForExactKey("TOAST"));
    System.out.println();
    System.out.println("Keys starting with 'T': " + tree.getKeysStartingWith("T"));
    System.out.println("Keys starting with 'TE': " + tree.getKeysStartingWith("TE"));
    System.out.println();
    System.out.println("Values for keys starting with 'TE': " + tree.getValuesForKeysStartingWith("TE"));
    System.out.println("Key-Value pairs for keys starting with 'TE': " + tree.getKeyValuePairsForKeysStartingWith("TE"));
    System.out.println();
    System.out.println("All keys in tree: " + tree.getKeysStartingWith(""));
    System.out.println("All values in tree: " + tree.getValuesForKeysStartingWith(""));
    System.out.println("All key-value pairs in tree: " + tree.getKeyValuePairsForKeysStartingWith(""));
}
}}}

==== Output ====
{{{
Tree structure:
○
└── ○ T
    ├── ○ E
    │   ├── ○ AM (3)
    │   └── ○ ST (1)
    └── ○ OAST (2)

Value for 'TEST' (exact match): 1
Value for 'TOAST' (exact match): 2

Keys starting with 'T': [TEAM, TEST, TOAST]
Keys starting with 'TE': [TEAM, TEST]

Values for keys starting with 'TE': [3, 1]
Key-Value pairs for keys starting with 'TE': [(TEAM, 3), (TEST, 1)]

All keys in tree: [TEAM, TEST, TOAST]
All values in tree: [3, 1, 2]
All key-value pairs in tree: [(TEAM, 3), (TEST, 1), (TOAST, 2)]
}}}


=== Concurrent Reversed Radix Tree ===
Code:
{{{
public static void main(String[] args) {
    ReversedRadixTree<Integer> tree = new ConcurrentReversedRadixTree<Integer>(new NaiveCharArrayNodeFactory());

    tree.put("TEST", 1);
    tree.put("TOAST", 2);
    tree.put("TEAM", 3);

    System.out.println("Tree structure:");
    // PrettyPrintable is a non-public API for testing, prints semi-graphical representations of trees...
    PrettyPrintUtil.prettyPrint((PrettyPrintable)tree, System.out);

    System.out.println();
    System.out.println("Value for 'TEST' (exact match): " + tree.getValueForExactKey("TEST"));
    System.out.println("Value for 'TOAST' (exact match): " + tree.getValueForExactKey("TOAST"));
    System.out.println();
    System.out.println("Keys ending with 'ST': " + tree.getKeysEndingWith("ST"));
    System.out.println("Keys ending with 'M': " + tree.getKeysEndingWith("M"));
    System.out.println();
    System.out.println("Values for keys ending with 'ST': " + tree.getValuesForKeysEndingWith("ST"));
    System.out.println("Key-Value pairs for keys ending with 'ST': " + tree.getKeyValuePairsForKeysEndingWith("ST"));
    System.out.println();
    System.out.println("All keys in tree: " + tree.getKeysEndingWith(""));
    System.out.println("All values in tree: " + tree.getValuesForKeysEndingWith(""));
    System.out.println("All key-value pairs in tree: " + tree.getKeyValuePairsForKeysEndingWith(""));
}
}}}

Output:
{{{
Tree structure:
○
├── ○ MAET (3)
└── ○ TS
    ├── ○ AOT (2)
    └── ○ ET (1)

Value for 'TEST' (exact match): 1
Value for 'TOAST' (exact match): 2

Keys ending with 'ST': [TOAST, TEST]
Keys ending with 'M': [TEAM]

Values for keys ending with 'ST': [2, 1]
Key-Value pairs for keys ending with 'ST': [(TOAST, 2), (TEST, 1)]

All keys in tree: [TEAM, TOAST, TEST]
All values in tree: [3, 2, 1]
All key-value pairs in tree: [(TEAM, 3), (TOAST, 2), (TEST, 1)]
}}}


=== Concurrent Inverted Radix Tree / Scan Documents For Keywords ===
Code:
{{{
public static void main(String[] args) {
    InvertedRadixTree<Integer> tree = new ConcurrentInvertedRadixTree<Integer>(new NaiveCharArrayNodeFactory());

    tree.put("TEST", 1);
    tree.put("TOAST", 2);
    tree.put("TEAM", 3);

    System.out.println("Tree structure:");
    // PrettyPrintable is a non-public API for testing, prints semi-graphical representations of trees...
    PrettyPrintUtil.prettyPrint((PrettyPrintable)tree, System.out);

    System.out.println();
    System.out.println("Value for 'TEST' (exact match): " + tree.getValueForExactKey("TEST"));
    System.out.println("Value for 'TOAST' (exact match): " + tree.getValueForExactKey("TOAST"));
    System.out.println();
    System.out.println("Keys contained in 'MY TEAM LIKES TOAST': " + tree.getKeysContainedIn("MY TEAM LIKES TOAST"));
    System.out.println("Keys contained in 'MY TEAM LIKES TOASTERS': " + tree.getKeysContainedIn("MY TEAM LIKES TOASTERS"));
    System.out.println("Values for keys contained in 'MY TEAM LIKES TOAST': " + tree.getValuesForKeysContainedIn("MY TEAM LIKES TOAST"));
    System.out.println("Key-value pairs for keys contained in 'MY TEAM LIKES TOAST': " + tree.getKeyValuePairsForKeysContainedIn("MY TEAM LIKES TOAST"));
}
}}}

Output:
{{{
Tree structure:
○
└── ○ T
    ├── ○ E
    │   ├── ○ AM (3)
    │   └── ○ ST (1)
    └── ○ OAST (2)

Value for 'TEST' (exact match): 1
Value for 'TOAST' (exact match): 2

Keys contained in 'MY TEAM LIKES TOAST': [TEAM, TOAST]
Keys contained in 'MY TEAM LIKES TOASTERS': [TEAM, TOAST]
Values for keys contained in 'MY TEAM LIKES TOAST': [3, 2]
Key-value pairs for keys contained in 'MY TEAM LIKES TOAST': [(TEAM, 3), (TOAST, 2)]
}}}


=== Concurrent Suffix Tree ===
Code:
{{{
public static void main(String[] args) {
    System.out.println("Suffixes for 'TEST': " + TestUtils.iterableToString(CharSequenceUtil.generateSuffixes("TEST")));
    System.out.println("Suffixes for 'TOAST': " + TestUtils.iterableToString(CharSequenceUtil.generateSuffixes("TOAST")));
    System.out.println("Suffixes for 'TEAM': " + TestUtils.iterableToString(CharSequenceUtil.generateSuffixes("TEAM")));

    SuffixTree<Integer> tree = new ConcurrentSuffixTree<Integer>(new NaiveCharArrayNodeFactory());

    tree.put("TEST", 1);
    tree.put("TOAST", 2);
    tree.put("TEAM", 3);

    System.out.println();
    System.out.println("Tree structure:");
    // PrettyPrintable is a non-public API for testing, prints semi-graphical representations of trees...
    PrettyPrintUtil.prettyPrint((PrettyPrintable)tree, System.out);

    System.out.println();
    System.out.println("Value for 'TEST' (exact match): " + tree.getValueForExactKey("TEST"));
    System.out.println("Value for 'TOAST' (exact match): " + tree.getValueForExactKey("TOAST"));
    System.out.println();
    System.out.println("Keys ending with 'ST': " + tree.getKeysEndingWith("ST"));
    System.out.println("Keys ending with 'M': " + tree.getKeysEndingWith("M"));
    System.out.println("Values for keys ending with 'ST': " + tree.getValuesForKeysEndingWith("ST"));
    System.out.println("Key-Value pairs for keys ending with 'ST': " + tree.getKeyValuePairsForKeysEndingWith("ST"));
    System.out.println();
    System.out.println("Keys containing 'TE': " + tree.getKeysContaining("TE"));
    System.out.println("Keys containing 'A': " + tree.getKeysContaining("A"));
    System.out.println("Values for keys containing 'A': " + tree.getValuesForKeysContaining("A"));
    System.out.println("Key-Value pairs for keys containing 'A': " + tree.getKeyValuePairsForKeysContaining("A"));
    System.out.println();
    System.out.println("All keys in tree: " + tree.getKeysContaining(""));
    System.out.println("All values in tree: " + tree.getValuesForKeysContaining(""));
    System.out.println("All key-value pairs in tree: " + tree.getKeyValuePairsForKeysContaining(""));
}
}}}

Output:
{{{
Suffixes for 'TEST': [TEST, EST, ST, T]
Suffixes for 'TOAST': [TOAST, OAST, AST, ST, T]
Suffixes for 'TEAM': [TEAM, EAM, AM, M]

Tree structure:
○
├── ○ A
│   ├── ○ M ([TEAM])
│   └── ○ ST ([TOAST])
├── ○ E
│   ├── ○ AM ([TEAM])
│   └── ○ ST ([TEST])
├── ○ M ([TEAM])
├── ○ OAST ([TOAST])
├── ○ ST ([TOAST, TEST])
└── ○ T ([TOAST, TEST])
    ├── ○ E
    │   ├── ○ AM ([TEAM])
    │   └── ○ ST ([TEST])
    └── ○ OAST ([TOAST])

Value for 'TEST' (exact match): 1
Value for 'TOAST' (exact match): 2

Keys ending with 'ST': [TOAST, TEST]
Keys ending with 'M': [TEAM]
Values for keys ending with 'ST': [2, 1]
Key-Value pairs for keys ending with 'ST': [(TEST, 1), (TOAST, 2)]

Keys containing 'TE': [TEAM, TEST]
Keys containing 'A': [TEAM, TOAST]
Values for keys containing 'A': [3, 2]
Key-Value pairs for keys containing 'A': [(TEAM, 3), (TOAST, 2)]

All keys in tree: [TEAM, TOAST, TEST]
All values in tree: [3, 2, 1]
All key-value pairs in tree: [(TEAM, 3), (TOAST, 2), (TEST, 1)]
}}}


=== Find Longest Common Substring in a Collection of Documents ===
Code:
{{{
static final String document1 =
        "albert einstein, was a german theoretical physicist who developed the theory of general relativity";

static final String document2 =
        "near the beginning of his career, albert einstein thought that newtonian mechanics was no longer " +
        "enough to reconcile the laws of classical mechanics with the laws of the electromagnetic field";

static final String document3 =
        "in late summer 1895, at the age of sixteen, albert einstein sat the entrance examinations for " +
        "the swiss federal polytechnic in zurich";

public static void main(String[] args) {
    LCSubstringSolver solver = new LCSubstringSolver(new NaiveCharSequenceNodeFactory());

    solver.add(document1);
    solver.add(document2);
    solver.add(document3);

    CharSequence longestCommonSubstring = solver.getLongestCommonSubstring();
    System.out.println("Longest common substring: " + CharSequenceUtil.toString(longestCommonSubstring));
}
}}}

Output:
{{{
Longest common substring: albert einstein
}}}