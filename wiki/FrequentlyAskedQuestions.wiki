#summary Frequently Asked Questions

Frequently Asked Questions. For various values of "frequently".
<wiki:toc max_depth="3" />

== Does the Concurrent Suffix Tree implement Ukkonen's algorithm? ==
[http://en.wikipedia.org/wiki/Ukkonen%27s_algorithm Ukkonen's algorithm] is a method to construct a suffix tree in _linear-time_ [O(n) or O(n logn)] by scanning a string from beginning-to-end in a single pass, adding nodes for suffixes in a single pass. It is the latest in a series of suffix tree construction algorithms, the earlier algorithms (Weiner and !McCreight) supporting construction in linear time but by scanning from end-to-beginning.

The Concurrent Suffix Tree in this project does _not_ implement Ukkonen's algorithm, because _Ukkonen's algorithm is by definition not thread-safe_. None of these algorithms have been explicitly designed with concurrency in mind. Ukkonen's algorithm specifies that _incomplete suffixes_ must be added to the tree, to be completed as the algorithm progresses. This would certainly allow concurrent reading threads to observe the tree in an inconsistent state.

However... Concurrent Suffix Tree does include _hooks_ for implementing Ukkonen's algorithm, Weiner's algorithm or !McCreight's algorithm, or derivatives thereof, in future, with some tradeoffs. There is support internally in Concurrent Suffix Tree to use a read-write lock, such that writing threads can block reading threads, but otherwise reading threads get concurrent access when writes are not taking place. A derivative class could use this to implement an O(n) insertion algorithm (e.g. `tree.putBlocking(key, value)`), so trading concurrency _temporarily_ for insertion speed.

It should also be noted that the current implementation when using [http://concurrent-trees.googlecode.com/svn/concurrent-trees/javadoc/apidocs/com/googlecode/concurrenttrees/radix/node/concrete/DefaultCharSequenceNodeFactory.html DefaultCharSequenceNodeFactory], does not incur the overhead of string copying in inserts, so might actually possess some benefits of the approaches used in [http://europa.zbh.uni-hamburg.de/pubs/pdf/GieKur1997.pdf Ukkonen's algorithm and its predecessors] (PDF).

Ukkonen's algorithm in particular does not seem to lend itself well to concurrency, and would require coarse locking. An algorithm based on right-to-left scanning of strings, inserting the shortest suffix first, would be most amenable to constructing a _generalized_ suffix tree (where the tree cannot be assumed to be empty) in O(n) or O(n logn) time for each key, while involving less or potentially no read locks.

== Do you have a comic about Depth-First Search? ==
Yes certainly, glad you asked!

Credit: [http://xkcd.com/ xkcd.com], [http://xkcd.com/license.html Creative Commons Attribution-NonCommercial 2.5 License]
[http://concurrent-trees.googlecode.com/svn/wiki/images/dfs-comic.png]